<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Gen V41 - Variation</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: sans-serif; }
        canvas { display: block; outline: none; }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(30, 30, 30, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            width: 260px;
            border: 1px solid #444;
            font-size: 13px;
            color: #eee;
            z-index: 100;
            max-height: 95vh;
            overflow-y: auto;
        }

        .control-group { margin-bottom: 10px; }
        label { display: block; font-weight: 700; margin-bottom: 4px; color: #ccc; display: flex; justify-content: space-between; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #fff; }
        
        button {
            width: 100%;
            padding: 8px; 
            margin-top: 5px;
            background: #eee;
            color: #111;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: background 0.2s;
            font-size: 11px;
        }
        button:hover { background: #fff; }
        
        .angle-inputs { display: flex; gap: 8px; margin-bottom: 10px; }
        .angle-inputs div { flex: 1; }
        .angle-inputs input { 
            width: 100%; background: #222; border: 1px solid #555; color: #fff; 
            padding: 4px; border-radius: 3px; text-align: center;
        }
        .angle-inputs span { font-size: 10px; color: #888; display: block; text-align: center; margin-bottom: 2px;}

        .view-group { display: flex; gap: 4px; margin-bottom: 12px; }
        .view-group button { margin-top: 0; flex: 1; background: #333; color: #ccc; border: 1px solid #555; }
        .view-group button:hover { background: #555; color: #fff; }

        .btn-group { display: flex; gap: 5px; margin-top: 10px; }
        .btn-group button { margin-top: 0; }

        button.primary { background: #4a90e2; color: white; }
        button.primary:hover { background: #357abd; }
        button.secondary { background: #e2a04a; color: white; }
        button.secondary:hover { background: #bd843b; }
        button.dark { background: #555; color: #fff; }
        button.dark:hover { background: #777; }
        button:disabled { background: #555; color: #888; cursor: not-allowed; }
        
        .val { color: #888; font-weight: normal; }
        
        #loading { display: none; text-align: center; color: #888; margin-top: 5px; font-style: italic; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
</head>
<body>

<div id="controls">
    <div class="control-group">
        <label>Fisheye (FOV) <span class="val" id="fovVal">80</span></label>
        <input type="range" id="fov" min="10" max="170" value="80">
    </div>
    
    <div class="control-group">
        <label>City Area <span class="val" id="areaVal">2000</span></label>
        <input type="range" id="area" min="800" max="8000" step="100" value="2000">
    </div>

    <div class="control-group">
        <label>Major Grid Size <span class="val" id="majorSpaceVal">600</span></label>
        <input type="range" id="majorSpace" min="300" max="1000" step="50" value="600">
    </div>
    <div class="control-group">
        <label>Subdivisions <span class="val" id="subdivVal">2</span></label>
        <input type="range" id="subdiv" min="1" max="5" step="1" value="2">
    </div>

    <div class="control-group">
        <label>Major Road Width <span class="val" id="majorWidthVal">60</span></label>
        <input type="range" id="majorWidth" min="30" max="120" value="60">
    </div>
    <div class="control-group">
        <label>Minor Road Width <span class="val" id="minorWidthVal">20</span></label>
        <input type="range" id="minorWidth" min="10" max="50" value="20">
    </div>

    <div class="control-group">
        <label>Height Scale <span class="val" id="heightVal">120</span></label>
        <input type="range" id="height" min="20" max="300" value="120">
    </div>
    <div class="control-group">
        <label>Height Variance <span class="val" id="hVarVal">0.5</span></label>
        <input type="range" id="hVar" min="0" max="1.0" step="0.1" value="0.5">
    </div>
    <div class="control-group">
        <label>Width/Depth Variance <span class="val" id="sVarVal">0.3</span></label>
        <input type="range" id="sVar" min="0" max="1.0" step="0.1" value="0.3">
    </div>

    <div class="control-group">
        <label>Detail Scale <span class="val" id="scaleVal">3</span></label>
        <input type="range" id="scale" min="1" max="6" step="0.5" value="3">
    </div>
    <div class="control-group">
        <label>Detail Darkness <span class="val" id="darknessVal">50%</span></label>
        <input type="range" id="darkness" min="0" max="100" step="5" value="50">
    </div>
    <div class="control-group">
        <label>Roof Clutter <span class="val" id="clutterVal">0.6</span></label>
        <input type="range" id="clutter" min="0" max="1.0" step="0.1" value="0.6">
    </div>
    <div class="control-group">
        <label>Railing Chance <span class="val" id="railingVal">0.4</span></label>
        <input type="range" id="railing" min="0" max="1.0" step="0.1" value="0.4">
    </div>

    <hr style="border: 0; border-top: 1px solid #444; margin: 10px 0;">
    <div class="control-group">
        <label>Sun Rotation <span class="val" id="sunRotVal">45°</span></label>
        <input type="range" id="sunRot" min="0" max="360" value="45">
    </div>
    <div class="control-group">
        <label>Sun Height <span class="val" id="sunHeightVal">60°</span></label>
        <input type="range" id="sunHeight" min="10" max="90" value="60">
    </div>

    <div class="angle-inputs">
        <div>
            <span>Vertical (Polar)</span>
            <input type="number" id="polarInput" value="60" step="1">
        </div>
        <div>
            <span>Horizontal (Azimuth)</span>
            <input type="number" id="azimuthInput" value="45" step="1">
        </div>
    </div>

    <div class="view-group">
        <button id="viewTop">Top View</button>
        <button id="viewSide">Side View</button>
        <button id="viewPlanet">Tiny Planet</button>
    </div>
    
    <button id="generateBtn">Rebuild City</button>
    
    <div class="btn-group">
        <button id="exportPngBtn">Save View</button>
        <button id="exportDepthBtn" class="primary">Save Depth</button>
    </div>
    <div class="btn-group">
        <button id="exportShadowBtn" class="dark">Save Shadow/Shade</button>
        <button id="exportDetailBtn" class="secondary">Save Detail Layer</button>
    </div>
    
    <div id="loading">Processing...</div>
</div>

<script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 50000);
    camera.position.set(600, 600, 600);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // --- LIGHTING ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 4096;
    dirLight.shadow.mapSize.height = 4096;
    dirLight.shadow.normalBias = 0.05; 
    dirLight.shadow.bias = -0.0001; 
    let d = 2500;
    dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
    dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
    dirLight.shadow.camera.far = 10000;
    scene.add(dirLight);

    const fillLight = new THREE.DirectionalLight(0x9999ff, 0.3);
    fillLight.position.set(-500, 200, -500);
    scene.add(fillLight);

    let cityGroup = new THREE.Group();
    scene.add(cityGroup);
    let maxCityHeight = 100; 

    // UI Handling
    const els = {
        fov: document.getElementById('fov'),
        area: document.getElementById('area'),
        majorSpace: document.getElementById('majorSpace'),
        subdiv: document.getElementById('subdiv'),
        majorWidth: document.getElementById('majorWidth'),
        minorWidth: document.getElementById('minorWidth'),
        height: document.getElementById('height'),
        hVar: document.getElementById('hVar'),
        sVar: document.getElementById('sVar'),
        scale: document.getElementById('scale'),
        darkness: document.getElementById('darkness'),
        clutter: document.getElementById('clutter'),
        railing: document.getElementById('railing'),
        sunRot: document.getElementById('sunRot'),
        sunHeight: document.getElementById('sunHeight'),
        btn: document.getElementById('generateBtn'),
        viewTop: document.getElementById('viewTop'),
        viewSide: document.getElementById('viewSide'),
        viewPlanet: document.getElementById('viewPlanet'),
        polarInput: document.getElementById('polarInput'),
        azInput: document.getElementById('azimuthInput'),
        exportPngBtn: document.getElementById('exportPngBtn'),
        exportDepthBtn: document.getElementById('exportDepthBtn'),
        exportDetailBtn: document.getElementById('exportDetailBtn'),
        exportShadowBtn: document.getElementById('exportShadowBtn'),
        loading: document.getElementById('loading')
    };

    Object.keys(els).forEach(key => {
        if(key.includes('Btn') || key.includes('view') || key.includes('Input') || key === 'loading') return;
        els[key].addEventListener('input', (e) => {
            let valTxt = e.target.value;
            if(key === 'darkness') valTxt += '%';
            if(key.includes('sun')) {
                valTxt += '°';
                updateSun();
            }
            document.getElementById(key + 'Val').innerText = valTxt;
            
            if(key === 'fov') {
                camera.fov = parseInt(e.target.value);
                camera.updateProjectionMatrix();
            } else if (!key.includes('sun')) {
                generateCity();
            }
        });
    });

    els.btn.addEventListener('click', generateCity);
    els.exportPngBtn.addEventListener('click', () => saveImage('view'));
    els.exportDepthBtn.addEventListener('click', () => saveImage('depth'));
    els.exportDetailBtn.addEventListener('click', () => saveImage('detail'));
    els.exportShadowBtn.addEventListener('click', () => saveImage('shadow'));

    // --- SUN LOGIC ---
    function updateSun() {
        const rot = THREE.MathUtils.degToRad(parseInt(els.sunRot.value));
        const phi = THREE.MathUtils.degToRad(90 - parseInt(els.sunHeight.value));
        const dist = 3000;
        const x = dist * Math.sin(phi) * Math.cos(rot);
        const y = dist * Math.cos(phi);
        const z = dist * Math.sin(phi) * Math.sin(rot);
        dirLight.position.set(x, y, z);
    }
    updateSun();

    // --- CAMERA LOGIC ---
    controls.addEventListener('change', () => {
        const spherical = new THREE.Spherical().setFromVector3(camera.position);
        const polarDeg = Math.round(THREE.MathUtils.radToDeg(spherical.phi));
        const azDeg = Math.round(THREE.MathUtils.radToDeg(spherical.theta));
        if (document.activeElement !== els.polarInput) els.polarInput.value = polarDeg;
        if (document.activeElement !== els.azInput) els.azInput.value = azDeg;
    });

    const updateCameraFromInputs = () => {
        const pVal = parseFloat(els.polarInput.value);
        const aVal = parseFloat(els.azInput.value);
        if (isNaN(pVal) || isNaN(aVal)) return;
        const polar = THREE.MathUtils.degToRad(pVal);
        const az = THREE.MathUtils.degToRad(aVal);
        const dist = camera.position.distanceTo(new THREE.Vector3(0,0,0));
        const spherical = new THREE.Spherical(dist, polar, az);
        camera.position.setFromSpherical(spherical);
        camera.lookAt(0,0,0);
        controls.update();
    };

    els.polarInput.addEventListener('input', updateCameraFromInputs);
    els.azInput.addEventListener('input', updateCameraFromInputs);

    // View Presets
    els.viewTop.addEventListener('click', () => {
        controls.target.set(0,0,0);
        const mapSize = parseInt(els.area.value);
        camera.position.set(0, mapSize * 0.8, 0); 
        camera.lookAt(0,0,0);
        camera.fov = 80; camera.updateProjectionMatrix();
        els.fov.value = 80; document.getElementById('fovVal').innerText = "80";
        controls.update();
        els.polarInput.value = 0; els.azInput.value = 0;
    });

    els.viewSide.addEventListener('click', () => {
        controls.target.set(0,0,0);
        const mapSize = parseInt(els.area.value);
        const dist = mapSize * 0.7;
        const polar = THREE.MathUtils.degToRad(60); 
        const az = THREE.MathUtils.degToRad(45);
        const spherical = new THREE.Spherical(dist, polar, az);
        camera.position.setFromSpherical(spherical);
        camera.lookAt(0,0,0);
        camera.fov = 80; camera.updateProjectionMatrix();
        els.fov.value = 80; document.getElementById('fovVal').innerText = "80";
        controls.update();
    });

    els.viewPlanet.addEventListener('click', () => {
        controls.target.set(0,0,0);
        camera.position.set(0.1, 800, 0); 
        camera.lookAt(0,0,0);
        camera.fov = 160; camera.updateProjectionMatrix();
        els.fov.value = 160; document.getElementById('fovVal').innerText = "160";
        controls.update();
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- GEOMETRY ---
    function applyVertexColor(geometry, color) {
        const count = geometry.attributes.position.count;
        const colors = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
        }
        geometry.setAttribute('detailColor', new THREE.BufferAttribute(colors, 3));
    }

    function createDetailedBuilding(w, h, d, x, z, floorH, detailColor, railingChance) {
        const geoms = [];
        const white = new THREE.Color(1.0, 1.0, 1.0); 
        const black = new THREE.Color(0.0, 0.0, 0.0); 

        const coreGeo = new THREE.BoxGeometry(w, h, d);
        coreGeo.translate(x, h/2, z);
        applyVertexColor(coreGeo, white);
        geoms.push(coreGeo);

        const style = Math.floor(Math.random() * 4);
        if (h > 20 && w > 10 && d > 10 && style > 0) {
            const ledgeProtrusion = 1.5; 
            const numFloors = Math.floor(h / floorH);

            if (style === 1 || style === 2) { 
                for(let i=1; i<numFloors; i++) {
                    const yPos = i * floorH;
                    const ledgeGeo = new THREE.BoxGeometry(w + ledgeProtrusion*2, floorH * 0.15, d + ledgeProtrusion*2);
                    ledgeGeo.translate(x, yPos, z);
                    applyVertexColor(ledgeGeo, detailColor);
                    geoms.push(ledgeGeo);
                }
            }
            if (style === 2 || style === 3) {
                const spacing = Math.max(8, floorH * 1.5); 
                const colsX = Math.floor(w / spacing);
                const colsZ = Math.floor(d / spacing);
                for(let i=0; i<=colsX; i++) {
                    const xOff = (i * (w/colsX)) - (w/2);
                    const p1 = new THREE.BoxGeometry(1.5, h, 1.5);
                    p1.translate(x + xOff, h/2, z + d/2);
                    applyVertexColor(p1, detailColor);
                    geoms.push(p1);
                    const p2 = new THREE.BoxGeometry(1.5, h, 1.5);
                    p2.translate(x + xOff, h/2, z - d/2);
                    applyVertexColor(p2, detailColor);
                    geoms.push(p2);
                }
                for(let i=0; i<=colsZ; i++) {
                    const zOff = (i * (d/colsZ)) - (d/2);
                    const p1 = new THREE.BoxGeometry(1.5, h, 1.5);
                    p1.translate(x + w/2, h/2, z + zOff);
                    applyVertexColor(p1, detailColor);
                    geoms.push(p1);
                    const p2 = new THREE.BoxGeometry(1.5, h, 1.5);
                    p2.translate(x - w/2, h/2, z + zOff);
                    applyVertexColor(p2, detailColor);
                    geoms.push(p2);
                }
            }
        }

        if (Math.random() < railingChance && w > 20 && d > 20) {
            const railH = floorH * 0.4; 
            const railThick = 1.5;
            const roofY = h; 

            const r1 = new THREE.BoxGeometry(w, railH, railThick);
            r1.translate(x, roofY + railH/2, z + d/2 - railThick/2);
            applyVertexColor(r1, white); 
            geoms.push(r1);

            const r2 = new THREE.BoxGeometry(w, railH, railThick);
            r2.translate(x, roofY + railH/2, z - d/2 + railThick/2);
            applyVertexColor(r2, white);
            geoms.push(r2);

            const r3 = new THREE.BoxGeometry(railThick, railH, d - 2*railThick);
            r3.translate(x + w/2 - railThick/2, roofY + railH/2, z);
            applyVertexColor(r3, white);
            geoms.push(r3);

            const r4 = new THREE.BoxGeometry(railThick, railH, d - 2*railThick);
            r4.translate(x - w/2 + railThick/2, roofY + railH/2, z);
            applyVertexColor(r4, white);
            geoms.push(r4);
        }

        if (geoms.length > 0) return THREE.BufferGeometryUtils.mergeBufferGeometries(geoms);
        return null;
    }

    function generateCity() {
        while(cityGroup.children.length > 0){ 
            const obj = cityGroup.children[0];
            if(obj.geometry) obj.geometry.dispose();
            if(obj.material) {
                if(Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose());
                else obj.material.dispose();
            }
            cityGroup.remove(obj); 
        }

        const mapSize = parseInt(els.area.value); 
        const majorSpacing = parseInt(els.majorSpace.value);
        const subdivisions = parseInt(els.subdiv.value);
        const majorWidth = parseInt(els.majorWidth.value);
        const minorWidth = parseInt(els.minorWidth.value);
        
        const baseHeight = parseInt(els.height.value);
        const hVar = parseFloat(els.hVar.value); // Height Variance
        const sVar = parseFloat(els.sVar.value); // Size Variance

        const clutterChance = parseFloat(els.clutter.value);
        const detailScale = parseFloat(els.scale.value); 
        const floorH = 2.5 * detailScale; 
        const railingChance = parseFloat(els.railing.value);

        // Update Ground Plane
        let ground = scene.getObjectByName('ground');
        if (!ground) {
            const groundGeo = new THREE.PlaneGeometry(1, 1);
            groundGeo.rotateX(-Math.PI / 2);
            groundGeo.translate(0, -0.1, 0);
            const groundMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
            ground = new THREE.Mesh(groundGeo, groundMat);
            ground.name = 'ground';
            ground.receiveShadow = true;
            scene.add(ground);
        }
        ground.scale.set(mapSize * 2, mapSize * 2, 1); 

        // Update Shadow Camera
        const d = mapSize * 0.8;
        dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
        dirLight.shadow.camera.updateProjectionMatrix();

        const darknessMult = 1.0 - (parseInt(els.darkness.value) / 100.0);
        const detailColor = new THREE.Color(darknessMult, darknessMult, darknessMult);
        const white = new THREE.Color(1.0, 1.0, 1.0);

        // --- GRID ALGORITHM ---
        const blocks = [];
        
        function getGridLines(size, spacing, subs, wMajor, wMinor) {
            const half = size / 2;
            const lines = []; 
            const count = Math.ceil(half / spacing);
            for(let i = -count; i <= count; i++) {
                const pos = i * spacing;
                lines.push({ pos: pos, width: wMajor });
                const subStep = spacing / (subs + 1);
                for(let k=1; k<=subs; k++) {
                    const mPos = pos + (k * subStep);
                    if (mPos < half) {
                        lines.push({ pos: mPos, width: wMinor });
                    }
                }
            }
            return lines.filter(l => l.pos > -half && l.pos < half).sort((a,b) => a.pos - b.pos);
        }

        const xLines = getGridLines(mapSize, majorSpacing, subdivisions, majorWidth, minorWidth);
        const zLines = getGridLines(mapSize, majorSpacing, subdivisions, majorWidth, minorWidth);
        const halfSize = mapSize/2;
        
        const xIntervals = []; 
        let currentX = -halfSize;
        xLines.forEach(line => {
            const roadStart = line.pos - line.width/2;
            const roadEnd = line.pos + line.width/2;
            if (roadStart > currentX) xIntervals.push({ start: currentX, end: roadStart });
            currentX = roadEnd;
        });
        if (currentX < halfSize) xIntervals.push({ start: currentX, end: halfSize });

        const zIntervals = [];
        let currentZ = -halfSize;
        zLines.forEach(line => {
            const roadStart = line.pos - line.width/2;
            const roadEnd = line.pos + line.width/2;
            if (roadStart > currentZ) zIntervals.push({ start: currentZ, end: roadStart });
            currentZ = roadEnd;
        });
        if (currentZ < halfSize) zIntervals.push({ start: currentZ, end: halfSize });

        xIntervals.forEach(xInt => {
            zIntervals.forEach(zInt => {
                blocks.push({ x: xInt.start + (xInt.end - xInt.start)/2, z: zInt.start + (zInt.end - zInt.start)/2, w: xInt.end - xInt.start, d: zInt.end - zInt.start });
            });
        });

        maxCityHeight = baseHeight;

        const allBuildingGeoms = [];
        const allJunkGeoms = [];
        const allJunkLines = []; 

        blocks.forEach(block => {
            const margin = 2; 
            const buildW = block.w - margin*2;
            const buildD = block.d - margin*2;
            if (buildW < 15 || buildD < 15) return;

            let subDivs = [];
            // Randomize unit width slightly per block for variety
            const unitSize = 50 + (Math.random() * 20); 
            
            if (buildW > buildD * 1.5) {
                const count = Math.max(1, Math.floor(buildW / unitSize));
                const segW = buildW / count;
                for(let k=0; k<count; k++) subDivs.push({ x: block.x - buildW/2 + segW*k + segW/2, z: block.z, w: segW-2, d: buildD });
            } else if (buildD > buildW * 1.5) {
                const count = Math.max(1, Math.floor(buildD / unitSize));
                const segD = buildD / count;
                for(let k=0; k<count; k++) subDivs.push({ x: block.x, z: block.z - buildD/2 + segD*k + segD/2, w: buildW, d: segD-2 });
            } else {
                subDivs.push({ x: block.x, z: block.z, w: buildW, d: buildD });
            }

            subDivs.forEach(b => {
                // Apply Width/Depth Variance (Shrink random amount)
                // sVar 0 = 100% fill. sVar 1 = up to 60% shrinkage
                const shrinkX = 1.0 - (Math.random() * sVar * 0.6);
                const shrinkZ = 1.0 - (Math.random() * sVar * 0.6);
                const finalW = b.w * shrinkX;
                const finalD = b.d * shrinkZ;

                // Center bias height
                const distFromCenter = Math.sqrt(b.x*b.x + b.z*b.z);
                const centerFactor = Math.max(0, 1 - (distFromCenter / (mapSize * 0.6)));
                
                // Height Calculation with Variance
                let h;
                const footprint = finalW * finalD;
                if (footprint < 800) h = 20 + Math.random() * 30; 
                else {
                    // Base calculated height
                    const hCalc = baseHeight * 0.5 + (baseHeight * centerFactor);
                    // Add Noise based on hVar
                    const noise = (Math.random() - 0.5) * 2 * (baseHeight * hVar); 
                    h = Math.max(30, hCalc + noise);
                }
                
                maxCityHeight = Math.max(maxCityHeight, h);
                const bGeo = createDetailedBuilding(finalW, h, finalD, b.x, b.z, floorH, detailColor, railingChance);
                if (bGeo) allBuildingGeoms.push(bGeo);

                if (Math.random() < clutterChance && finalW > 15 && finalD > 15) {
                    const count = Math.floor(Math.random() * 3) + 1;
                    for(let k=0; k<count; k++) {
                        const jw = Math.max(4, Math.random() * (finalW * 0.4));
                        const jd = Math.max(4, Math.random() * (finalD * 0.4));
                        const jh = 3 + Math.random() * 8; 
                        maxCityHeight = Math.max(maxCityHeight, h + jh);
                        const jx = (Math.random() * 2 - 1) * ((finalW/2) - (jw/2));
                        const jz = (Math.random() * 2 - 1) * ((finalD/2) - (jd/2));
                        
                        const junkGeo = new THREE.BoxGeometry(jw, jh, jd);
                        junkGeo.translate(b.x + jx, h + jh/2, b.z + jz);
                        applyVertexColor(junkGeo, white);
                        allJunkGeoms.push(junkGeo);

                        const edgeGeo = new THREE.EdgesGeometry(junkGeo);
                        allJunkLines.push(edgeGeo);
                    }
                }
            });
        });

        const matWhite = new THREE.MeshLambertMaterial({ color: 0xffffff });
        const matJunk = new THREE.MeshLambertMaterial({ color: 0xcccccc });

        if (allBuildingGeoms.length > 0) {
            const mergedBuildings = THREE.BufferGeometryUtils.mergeBufferGeometries(allBuildingGeoms);
            const cityMesh = new THREE.Mesh(mergedBuildings, matWhite);
            cityMesh.castShadow = true;
            cityMesh.receiveShadow = true;
            cityGroup.add(cityMesh);
            
            const edges = new THREE.EdgesGeometry(mergedBuildings, 25);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
            cityMesh.add(line);
        }

        if (allJunkGeoms.length > 0) {
            const mergedJunk = THREE.BufferGeometryUtils.mergeBufferGeometries(allJunkGeoms);
            const junkMesh = new THREE.Mesh(mergedJunk, matJunk);
            junkMesh.castShadow = true;
            junkMesh.receiveShadow = true;
            cityGroup.add(junkMesh);
        }

        if (allJunkLines.length > 0) {
            const mergedLines = THREE.BufferGeometryUtils.mergeBufferGeometries(allJunkLines);
            const junkContours = new THREE.LineSegments(mergedLines, new THREE.LineBasicMaterial({ color: 0x000000 }));
            junkContours.userData.isDetailLayer = true; 
            cityGroup.add(junkContours);
        }
    }

    // --- SHADERS ---
    const heightShader = {
        uniforms: { maxHeight: { value: 100.0 } },
        vertexShader: `
            varying float vWorldY;
            void main() {
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldY = worldPosition.y;
                gl_Position = projectionMatrix * viewMatrix * worldPosition;
            }
        `,
        fragmentShader: `
            uniform float maxHeight;
            varying float vWorldY;
            void main() {
                float h = clamp(vWorldY / maxHeight, 0.0, 1.0);
                gl_FragColor = vec4(vec3(h), 1.0);
            }
        `
    };

    const detailShader = {
        vertexShader: `
            attribute vec3 detailColor;
            varying vec3 vDetailColor;
            void main() {
                vDetailColor = detailColor;
                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            varying vec3 vDetailColor;
            void main() {
                if (vDetailColor.r > 0.5) {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
                } else {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                }
            }
        `
    };

    function saveImage(mode) {
        let btn;
        if(mode === 'view') btn = els.exportPngBtn;
        else if(mode === 'depth') btn = els.exportDepthBtn;
        else if(mode === 'shadow') btn = els.exportShadowBtn;
        else btn = els.exportDetailBtn;

        btn.disabled = true;
        els.loading.style.display = 'block';

        requestAnimationFrame(() => {
            const originalSize = new THREE.Vector2();
            renderer.getSize(originalSize);
            const size = 4096;
            renderer.setSize(size, size);
            
            const originalAspect = camera.aspect;
            camera.aspect = 1.0;
            camera.updateProjectionMatrix();

            const originalBackground = scene.background;
            const hiddenLines = [];

            if(mode !== 'view') {
                cityGroup.traverse(obj => {
                    if (obj.isLineSegments) {
                        obj.visible = false;
                        if (mode === 'detail' && obj.userData.isDetailLayer) {
                             obj.visible = true;
                        }
                        if (!obj.visible) hiddenLines.push(obj);
                    }
                });
            }

            const restoreMaterials = []; 

            if(mode === 'depth') {
                scene.background = new THREE.Color(0x000000); 
                const depthMat = new THREE.ShaderMaterial({
                    uniforms: { maxHeight: { value: maxCityHeight * 1.05 } }, 
                    vertexShader: heightShader.vertexShader,
                    fragmentShader: heightShader.fragmentShader
                });
                scene.overrideMaterial = depthMat;
            } 
            else if (mode === 'detail') {
                scene.background = null; 
                renderer.setClearColor(0x000000, 0); 
                const detMat = new THREE.ShaderMaterial({
                    vertexShader: detailShader.vertexShader,
                    fragmentShader: detailShader.fragmentShader,
                    transparent: false, blending: THREE.NoBlending 
                });
                cityGroup.traverse(obj => {
                    if (obj.isMesh) {
                        restoreMaterials.push({obj: obj, mat: obj.material});
                        obj.material = detMat;
                    }
                });
            }
            else if (mode === 'shadow') {
                scene.background = new THREE.Color(0xffffff); 
                const ground = scene.getObjectByName('ground');
                if(ground) {
                    restoreMaterials.push({obj: ground, mat: ground.material});
                    ground.material = new THREE.MeshLambertMaterial({ color: 0xffffff });
                }
                scene.overrideMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            }

            renderer.render(scene, camera);

            renderer.domElement.toBlob(blob => {
                const a = document.createElement('a');
                const url = URL.createObjectURL(blob);
                a.href = url;
                let filename = 'city_view.png';
                if(mode === 'depth') filename = 'city_depth_map.png';
                if(mode === 'detail') filename = 'city_detail_layer.png';
                if(mode === 'shadow') filename = 'city_shadow_map.png';
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);

                renderer.setSize(originalSize.x, originalSize.y);
                camera.aspect = originalAspect;
                camera.updateProjectionMatrix();
                
                if(mode !== 'view') {
                    scene.background = originalBackground;
                    scene.overrideMaterial = null;
                    renderer.setClearColor(0x000000, 1);
                    restoreMaterials.forEach(item => {
                        item.obj.material = item.mat;
                    });
                    hiddenLines.forEach(l => l.visible = true);
                }

                renderer.render(scene, camera);
                btn.disabled = false;
                els.loading.style.display = 'none';
            }, 'image/png');
        });
    }

    generateCity();

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

</script>
</body>
</html>
