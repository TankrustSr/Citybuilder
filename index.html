<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Gen V89 - Improved Skyline</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: sans-serif; }
        canvas { display: block; outline: none; }
        
        #controls {
            position: absolute; top: 10px; right: 10px; width: 260px;
            background: rgba(30, 30, 30, 0.95); padding: 15px;
            border-radius: 8px; border: 1px solid #444;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            color: #eee; font-size: 13px; z-index: 100;
            max-height: 95vh; overflow-y: auto;
        }

        .control-group { margin-bottom: 10px; }
        label { display: block; font-weight: 700; margin-bottom: 4px; color: #ccc; display: flex; justify-content: space-between; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #fff; }
        .val { color: #888; font-weight: normal; }

        button {
            width: 100%; padding: 8px; margin-top: 5px;
            background: #eee; color: #111; border: none; border-radius: 4px;
            cursor: pointer; font-weight: bold; text-transform: uppercase;
            transition: background 0.2s; font-size: 11px;
        }
        button:hover { background: #fff; }
        button.primary { background: #4a90e2; color: white; }
        button.dark { background: #555; color: white; }
        button.danger { background: #d9534f; color: white; }
        button.save { background: #28a745; color: white; margin-bottom: 5px; } 

        .btn-group { display: flex; gap: 5px; margin-top: 5px; }
        
        input[type=text], select {
            width: 100%; padding: 6px; margin-bottom: 5px; 
            background: #222; border: 1px solid #555; color: #fff; border-radius: 4px;
            box-sizing: border-box;
        }

        #status { 
            margin-top: 10px; padding: 5px; 
            background: #222; border: 1px solid #444; 
            color: #4f4; font-family: monospace; font-size: 10px; 
            text-align: center; white-space: pre-wrap;
        }
        #loading { display: none; text-align: center; color: #888; margin-top: 5px; font-style: italic; }
        hr { border: 0; border-top: 1px solid #444; margin: 10px 0; }
        
        .view-group { display: flex; gap: 5px; margin-top: 10px; }
        .view-group button { margin-top: 0; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
</head>
<body>

<div id="controls">
    <label>Saved Cities</label>
    <input type="text" id="saveName" placeholder="Enter name...">
    <div class="btn-group">
        <button id="saveBtn" class="save">Save</button>
        <button id="deleteBtn" class="danger">Delete</button>
    </div>
    <select id="saveList" style="margin-top:5px;"></select>
    <button id="loadBtn" class="dark">Load Selected</button>
    <hr>

    <div class="control-group">
        <label>Fisheye (FOV) <span class="val" id="fovVal">80</span></label>
        <input type="range" id="fov" min="10" max="170" value="80" data-type="camera">
    </div>
    <div class="control-group">
        <label>City Area <span class="val" id="areaVal">2000</span></label>
        <input type="range" id="area" min="800" max="8000" step="100" value="2000" data-type="layout">
    </div>

    <div class="control-group">
        <label>Major Grid Size <span class="val" id="majorSpaceVal">600</span></label>
        <input type="range" id="majorSpace" min="300" max="1000" step="50" value="600" data-type="layout">
    </div>
    <div class="control-group">
        <label>Subdivisions <span class="val" id="subdivVal">2</span></label>
        <input type="range" id="subdiv" min="1" max="5" step="1" value="2" data-type="layout">
    </div>
    <div class="control-group">
        <label>Major Road Width <span class="val" id="majorWidthVal">60</span></label>
        <input type="range" id="majorWidth" min="30" max="120" value="60" data-type="layout">
    </div>
    <div class="control-group">
        <label>Minor Road Width <span class="val" id="minorWidthVal">20</span></label>
        <input type="range" id="minorWidth" min="10" max="50" value="20" data-type="layout">
    </div>

    <div class="control-group">
        <label>Height <span class="val" id="heightVal">120</span></label>
        <input type="range" id="height" min="20" max="300" value="120" data-type="layout">
    </div>
    <div class="control-group">
        <label>Height Variance <span class="val" id="hVarVal">0.5</span></label>
        <input type="range" id="hVar" min="0" max="1.0" step="0.1" value="0.5" data-type="layout">
    </div>
    
    <div class="control-group">
        <label>Green Space <span class="val" id="greenVal">0.1</span></label>
        <input type="range" id="green" min="0" max="1.0" step="0.1" value="0.1" data-type="layout">
    </div>
    <div class="control-group">
        <label>Shape Complexity <span class="val" id="shapeVal">0.6</span></label>
        <input type="range" id="shape" min="0" max="1.0" step="0.1" value="0.6" data-type="layout">
    </div>
    <div class="control-group">
        <label>Style Variance <span class="val" id="styleVal">0.5</span></label>
        <input type="range" id="style" min="0" max="1.0" step="0.1" value="0.5" data-type="layout">
    </div>

    <div class="control-group">
        <label>Detail Scale <span class="val" id="scaleVal">3</span></label>
        <input type="range" id="scale" min="1" max="6" step="0.5" value="3" data-type="detail">
    </div>
    <div class="control-group">
        <label>Detail Darkness <span class="val" id="darknessVal">50%</span></label>
        <input type="range" id="darkness" min="0" max="100" step="5" value="50" data-type="material">
    </div>
    <div class="control-group">
        <label>Clutter <span class="val" id="clutterVal">0.6</span></label>
        <input type="range" id="clutter" min="0" max="1.0" step="0.1" value="0.6" data-type="detail">
    </div>
    <div class="control-group">
        <label>Railing <span class="val" id="railingVal">0.4</span></label>
        <input type="range" id="railing" min="0" max="1.0" step="0.1" value="0.4" data-type="detail">
    </div>

    <hr>
    <div class="control-group">
        <label>Sun Rotation <span class="val" id="sunRotVal">45°</span></label>
        <input type="range" id="sunRot" min="0" max="360" value="45" data-type="sun">
    </div>
    <div class="control-group">
        <label>Sun Height <span class="val" id="sunHeightVal">60°</span></label>
        <input type="range" id="sunHeight" min="10" max="90" value="60" data-type="sun">
    </div>

    <div class="angle-inputs">
        <div>
            <span>Vertical</span>
            <input type="number" id="polarInput" value="60" step="1">
        </div>
        <div>
            <span>Horizontal</span>
            <input type="number" id="azimuthInput" value="45" step="1">
        </div>
    </div>

    <div class="view-group">
        <button id="viewTop">Top View</button>
        <button id="viewSide">Side View</button>
        <button id="viewPlanet">Tiny Planet</button>
    </div>
    
    <button id="generateBtn">Rebuild City</button>
    <div id="status">Ready</div>
    
    <hr>
    <label style="margin-bottom:5px;">Export Resolution:</label>
    <select id="exportRes">
        <option value="4096" selected>4K (4096 x 4096)</option>
        <option value="8192">8K (8192 x 8192)</option>
    </select>

    <div class="btn-group">
        <button id="exportPngBtn">Save View</button>
        <button id="exportDepthBtn" class="primary">Save Depth</button>
    </div>
    <div class="btn-group">
        <button id="exportShadowBtn" class="dark">Save Shadow</button>
        <button id="exportDetailBtn" class="primary" style="background:#e2a04a;">Save Detail</button>
    </div>
    
    <div id="loading">Processing...</div>
</div>

<script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 50000);
    camera.position.set(600, 600, 600);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2); 
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 8192;
    dirLight.shadow.mapSize.height = 8192;
    dirLight.shadow.normalBias = 0.0; 
    dirLight.shadow.bias = -0.00005; 
    scene.add(dirLight);

    const fillLight = new THREE.DirectionalLight(0x9999ff, 0.5); 
    fillLight.position.set(-500, 200, -500);
    scene.add(fillLight);

    let cityGroup = new THREE.Group();
    scene.add(cityGroup);
    let coreGroup = new THREE.Group();
    cityGroup.add(coreGroup);
    let detailGroup = new THREE.Group();
    cityGroup.add(detailGroup);

    let maxCityHeight = 100;
    let buildingsData = []; 

    const els = {
        fov: document.getElementById('fov'),
        area: document.getElementById('area'),
        majorSpace: document.getElementById('majorSpace'),
        subdiv: document.getElementById('subdiv'),
        majorWidth: document.getElementById('majorWidth'),
        minorWidth: document.getElementById('minorWidth'),
        height: document.getElementById('height'),
        hVar: document.getElementById('hVar'),
        green: document.getElementById('green'),
        shape: document.getElementById('shape'),
        style: document.getElementById('style'),
        scale: document.getElementById('scale'),
        darkness: document.getElementById('darkness'),
        clutter: document.getElementById('clutter'),
        railing: document.getElementById('railing'),
        sunRot: document.getElementById('sunRot'),
        sunHeight: document.getElementById('sunHeight'),
        status: document.getElementById('status'),
        loading: document.getElementById('loading'),
        generate: document.getElementById('generateBtn'),
        saveBtn: document.getElementById('saveBtn'),
        loadBtn: document.getElementById('loadBtn'),
        deleteBtn: document.getElementById('deleteBtn'),
        saveName: document.getElementById('saveName'),
        saveList: document.getElementById('saveList'),
        exportPng: document.getElementById('exportPngBtn'),
        exportDepth: document.getElementById('exportDepthBtn'),
        exportShadow: document.getElementById('exportShadowBtn'),
        exportDetail: document.getElementById('exportDetailBtn'),
        exportRes: document.getElementById('exportRes'),
        polarInput: document.getElementById('polarInput'),
        azInput: document.getElementById('azimuthInput')
    };

    function updateSun() {
        if(!els.sunRot || !els.sunHeight) return;
        const rot = THREE.MathUtils.degToRad(parseInt(els.sunRot.value));
        const phi = THREE.MathUtils.degToRad(90 - parseInt(els.sunHeight.value));
        const dist = 3000;
        dirLight.position.set(dist * Math.sin(phi) * Math.cos(rot), dist * Math.cos(phi), dist * Math.sin(phi) * Math.sin(rot));
        const mapSize = parseInt(els.area.value);
        const margin = 200; const d = (mapSize / 2) + margin;
        dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
        dirLight.shadow.camera.near = 100; dirLight.shadow.camera.far = 10000; 
        dirLight.shadow.camera.updateProjectionMatrix();
    }

    function applyVertexColor(geometry, color) {
        const count = geometry.attributes.position.count;
        const colors = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
        }
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('detailColor', new THREE.BufferAttribute(colors, 3));
    }

    function safeBox(w, h, d, x, y, z) {
        if(isNaN(w) || isNaN(h) || isNaN(d) || w < 0.5 || h < 0.5 || d < 0.5) return null;
        if(isNaN(x) || isNaN(y) || isNaN(z)) return null;
        const g = new THREE.BoxGeometry(w, h, d);
        g.translate(x, y, z);
        return g;
    }

    function generateEntrance(doorW, doorH, x, y, z) {
        const frameThick = 1.2;
        const cores = []; const details = [];

        const hole = safeBox(doorW, doorH, frameThick*2, x, y, z - frameThick);
        if(hole) {
            applyVertexColor(hole, new THREE.Color(0.2, 0.2, 0.2)); 
            cores.push(hole);
        }

        const rnd = Math.random();
        let style = 'SIMPLE';
        if (rnd > 0.66) style = 'CANOPY';
        else if (rnd > 0.33) style = 'GRAND';

        if (style === 'SIMPLE' || style === 'CANOPY') {
            details.push(safeBox(doorW + frameThick*2, frameThick, frameThick*2, x, y + doorH/2 + frameThick/2, z));
            details.push(safeBox(frameThick, doorH + frameThick, frameThick*2, x - doorW/2 - frameThick/2, y, z));
            details.push(safeBox(frameThick, doorH + frameThick, frameThick*2, x + doorW/2 + frameThick/2, y, z));
            
            if (style === 'CANOPY') {
                 const canopyD = 3 + Math.random() * 3; 
                 details.push(safeBox(doorW + 4, 1, canopyD, x, y + doorH/2 + 2, z + canopyD/2 - frameThick));
            }
        } else if (style === 'GRAND') {
            const grandH = doorH * 1.4;
            const grandY = y + (grandH - doorH)/2;
            
            details.push(safeBox(doorW + 6, grandH + 2, 4, x, grandY, z + 1));
            details.push(safeBox(2, grandH, 4, x - doorW/2 - 2, grandY, z + 1));
            details.push(safeBox(2, grandH, 4, x + doorW/2 + 2, grandY, z + 1));
        }

        return { cores, details };
    }


    function generateDetailedWing(w, h, d, x, y, z, floorH, detailColor, railingChance, white, styleType, doorData) {
        const geoms = [];
        const core = safeBox(w, h, d, x, y, z);
        if(!core) return { cores:[], details:[] };
        applyVertexColor(core, white);
        const cores = [core];
        const details = [];

        if (h > 20 && w > 10 && d > 10) {
            
            if (styleType === 'STANDARD' || styleType === 'STEPPED' || styleType === 'TWIN') {
                const numFloors = Math.floor(h / floorH);
                const lp = 1.5; const lh = floorH * 0.15; 
                
                for(let i=1; i<numFloors; i++) {
                    const yPos = i * floorH;
                    if (yPos > h - 2) break; 
                    const ly = y - h/2 + yPos;
                    const fullW = w + lp*2; const fullD = d + lp*2;

                    let splitFront = false;
                    if (doorData && yPos < doorData.h) splitFront = true;

                    if (splitFront) {
                        const leftW = (w/2 - doorData.w/2) + lp;
                        const leftX = x - (doorData.w/2) - (leftW/2);
                        const rightW = (w/2 - doorData.w/2) + lp;
                        const rightX = x + (doorData.w/2) + (rightW/2);
                        
                        const p1L = safeBox(leftW, lh, lp, leftX, ly, z + d/2 + lp/2);
                        if(p1L) details.push(p1L);
                        const p1R = safeBox(rightW, lh, lp, rightX, ly, z + d/2 + lp/2);
                        if(p1R) details.push(p1R);
                    } else {
                        const p1 = safeBox(fullW, lh, lp, x, ly, z + d/2 + lp/2); 
                        if(p1) details.push(p1);
                    }

                    const p2 = safeBox(fullW, lh, lp, x, ly, z - d/2 - lp/2); if(p2) details.push(p2);
                    const p3 = safeBox(lp, lh, d, x - w/2 - lp/2, ly, z); if(p3) details.push(p3);
                    const p4 = safeBox(lp, lh, d, x + w/2 + lp/2, ly, z); if(p4) details.push(p4);
                }
            }
            else if (styleType === 'GLASS') {
                const spacing = 12;
                const colsX = Math.max(1, Math.floor(w / spacing));
                const colsZ = Math.max(1, Math.floor(d / spacing));
                for(let i=0; i<=colsX; i++) {
                    const xOff = (i * (w/colsX)) - (w/2);
                    const p1 = safeBox(1.5, h, 1.5, x + xOff, y, z + d/2); if(p1) details.push(p1);
                    const p2 = safeBox(1.5, h, 1.5, x + xOff, y, z - d/2); if(p2) details.push(p2);
                }
                for(let i=0; i<=colsZ; i++) {
                    const zOff = (i * (d/colsZ)) - (d/2);
                    const p1 = safeBox(1.5, h, 1.5, x + w/2, y, z + zOff); if(p1) details.push(p1);
                    const p2 = safeBox(1.5, h, 1.5, x - w/2, y, z + zOff); if(p2) details.push(p2);
                }
            }
        }

        if (Math.random() < railingChance && w > 20 && d > 20) {
            const railH = floorH * 0.4; const railThick = 1.5; const roofY = y + h/2; 
            const r1 = safeBox(w, railH, railThick, x, roofY + railH/2, z + d/2 - railThick/2); if(r1) details.push(r1);
            const r2 = safeBox(w, railH, railThick, x, roofY + railH/2, z - d/2 + railThick/2); if(r2) details.push(r2);
            const r3 = safeBox(railThick, railH, d - 2*railThick, x + w/2 - railThick/2, roofY + railH/2, z); if(r3) details.push(r3);
            const r4 = safeBox(railThick, railH, d - 2*railThick, x - w/2 + railThick/2, roofY + railH/2, z); if(r4) details.push(r4);
        }
        return { cores, details };
    }

    function buildGeometry(fullRebuild) {
        els.status.innerText = fullRebuild ? "Rebuilding Layout..." : "Updating Details...";
        els.status.style.color = "#aaa";

        const detailScale = parseFloat(els.scale.value);
        const floorH = 2.5 * detailScale;
        const darknessMult = 1.0 - (parseInt(els.darkness.value) / 100.0);
        const detailColor = new THREE.Color(darknessMult, darknessMult, darknessMult);
        const white = new THREE.Color(1,1,1);
        const railingChance = parseFloat(els.railing.value);
        const clutterChance = parseFloat(els.clutter.value);
        const styleVar = parseFloat(els.style.value);

        if (fullRebuild) {
            while(coreGroup.children.length > 0) { const o = coreGroup.children[0]; coreGroup.remove(o); if(o.geometry) o.geometry.dispose(); }
        }
        while(detailGroup.children.length > 0) { const o = detailGroup.children[0]; detailGroup.remove(o); if(o.geometry) o.geometry.dispose(); }

        const allCores = [];
        const allDetails = [];
        const junkGeoms = [];
        const junkLines = [];

        buildingsData.forEach(b => {
            const wings = [];
            
            if (b.style === 'STEPPED') {
                const tiers = 3; for(let i=0; i<tiers; i++) { const ratio = 1.0 - (i * 0.25); const tierH = b.h * ((i+1)/tiers); wings.push({w: b.w*ratio, d: b.d*ratio, x: 0, z: 0, h: tierH, isTop: i === tiers-1}); }
            } else if (b.style === 'TWIN') {
                wings.push({w: b.w, d: b.d, x: 0, z: 0, h: b.h*0.15, isTop: false}); wings.push({w: b.w*0.35, d: b.d*0.6, x: -b.w/4, z: 0, h: b.h, isTop: true}); wings.push({w: b.w*0.35, d: b.d*0.6, x: b.w/4, z: 0, h: b.h, isTop: true}); 
            } else if (b.shape === 'L') {
                wings.push({w: b.w, d: b.d*0.4, x:0, z:-b.d*0.3, h:b.h, isTop:true}); wings.push({w: b.w*0.4, d: b.d, x:-b.w*0.3, z:0, h:b.h, isTop:true});
            } else if (b.shape === 'U') {
                const thick = 0.35;
                const dBack = b.d * thick; wings.push({w: b.w, d: dBack, x: 0, z: -b.d/2 + dBack/2, h: b.h, isTop: true});
                const wLeg = b.w * thick; const dLeg = b.d - dBack;
                wings.push({w: wLeg, d: dLeg, x: -b.w/2 + wLeg/2, z: b.d/2 - dLeg/2, h: b.h, isTop: true});
                wings.push({w: wLeg, d: dLeg, x: b.w/2 - wLeg/2, z: b.d/2 - dLeg/2, h: b.h, isTop: true});
            } else { 
                wings.push({w: b.w, d: b.d, x: 0, z: 0, h: b.h, isTop: true});
            }

            const applyRot = (geo, x, z) => {
                if(b.rot !== 0) {
                    geo.rotateY(b.rot);
                    const cos = Math.cos(b.rot); const sin = Math.sin(b.rot);
                    geo.translate(b.x + x * cos - z * sin, 0, b.z + x * sin + z * cos);
                } else {
                    geo.translate(b.x + x, 0, b.z + z);
                }
            };
            const mRot = new THREE.Matrix4().makeRotationY(b.rot);
            const mPos = new THREE.Matrix4().makeTranslation(b.x, 0, b.z);
            const buildMat = new THREE.Matrix4().multiply(mPos).multiply(mRot);

            wings.forEach((wing, index) => {
                let doorData = null;
                if (index === 0 && wing.w > 30) {
                    let dH = 14 + Math.random()*4;
                    const maxH = wing.h - 3;
                    if(dH > maxH) dH = maxH;
                    if(dH >= 6) {
                        doorData = { w: 12 + Math.random()*8, h: dH };
                        const entrance = generateEntrance(doorData.w, doorData.h, wing.x, wing.h/2 - wing.h/2 + doorData.h/2, wing.z + wing.d/2 + 0.6); 
                        if (fullRebuild) entrance.cores.forEach(g => { applyRot(g, 0, 0); allCores.push(g); });
                        entrance.details.forEach(g => { applyRot(g, 0, 0); allDetails.push(g); });
                    }
                }

                const result = generateDetailedWing(wing.w, wing.h, wing.d, wing.x, wing.h/2, wing.z, floorH, detailColor, railingChance, white, b.style, doorData);
                if (fullRebuild) result.cores.forEach(g => { applyRot(g, 0, 0); allCores.push(g); });
                result.details.forEach(g => { applyRot(g, 0, 0); allDetails.push(g); });

                if (wing.isTop && Math.random() < clutterChance) {
                    const count = Math.floor(Math.random() * 2) + 1;
                    for(let k=0; k<count; k++) {
                        const jw = Math.max(3, Math.random() * (wing.w * 0.3));
                        const jd = Math.max(3, Math.random() * (wing.d * 0.3));
                        const jh = 3 + Math.random() * 6; 
                        const jx = (Math.random() * 2 - 1) * ((wing.w/2) - (jw/2) - 1);
                        const jz = (Math.random() * 2 - 1) * ((wing.d/2) - (jd/2) - 1);
                        const junk = safeBox(jw, jh, jd, wing.x + jx, wing.h + jh/2 - 0.2, wing.z + jz);
                        if(junk) {
                            applyVertexColor(junk, white);
                            applyRot(junk, 0, 0); 
                            junkGeoms.push(junk);
                            const boxRaw = new THREE.BoxGeometry(jw, jh, jd);
                            const edgesRaw = new THREE.EdgesGeometry(boxRaw);
                            const m = new THREE.Matrix4().makeTranslation(wing.x + jx, wing.h + jh/2 - 0.2, wing.z + jz);
                            edgesRaw.applyMatrix4(new THREE.Matrix4().copy(buildMat).multiply(m));
                            junkLines.push(edgesRaw);
                        }
                    }
                }
            });
        });

        if (fullRebuild && allCores.length > 0) {
            const merged = THREE.BufferGeometryUtils.mergeBufferGeometries(allCores);
            const mesh = new THREE.Mesh(merged, new THREE.MeshLambertMaterial({ vertexColors: THREE.VertexColors }));
            mesh.castShadow = true; mesh.receiveShadow = true;
            mesh.userData.isCore = true; 
            coreGroup.add(mesh);
        }

        if (allDetails.length > 0) {
            const merged = THREE.BufferGeometryUtils.mergeBufferGeometries(allDetails);
            applyVertexColor(merged, detailColor); 
            const mesh = new THREE.Mesh(merged, new THREE.MeshLambertMaterial({ vertexColors: THREE.VertexColors }));
            mesh.castShadow = true; mesh.receiveShadow = true;
            mesh.userData.isDetail = true; 
            detailGroup.add(mesh);
        }

        if (junkGeoms.length > 0) {
            const mergedJunk = THREE.BufferGeometryUtils.mergeBufferGeometries(junkGeoms);
            const jMesh = new THREE.Mesh(mergedJunk, new THREE.MeshLambertMaterial({ color: 0xcccccc }));
            jMesh.castShadow = true; jMesh.receiveShadow = true;
            jMesh.userData.isCore = true; 
            detailGroup.add(jMesh); 
        }
        
        junkLines.forEach(geo => {
            const l = new THREE.LineSegments(geo, new THREE.LineBasicMaterial({ color: 0x000000 }));
            l.userData.isDetail = true; 
            detailGroup.add(l);
        });

        els.status.innerText = "Ready";
        els.status.style.color = "#4f4";
    }

    function calculateLayout() {
        buildingsData = []; 
        maxCityHeight = 100;
        const mapSize = parseInt(els.area.value); 
        const majorSpace = parseInt(els.majorSpace.value);
        const majorWidth = parseInt(els.majorWidth.value);
        const minorW = parseInt(els.minorWidth.value);
        const heightScale = parseInt(els.height.value);
        const hVar = parseFloat(els.hVar.value);
        const greenChance = parseFloat(els.green.value);
        const shapeComp = parseFloat(els.shape.value);
        const styleVar = parseFloat(els.style.value);

        let ground = scene.getObjectByName('ground');
        if (!ground) {
            const g = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), new THREE.MeshLambertMaterial({ color: 0x111111 }));
            g.name = 'ground'; g.rotation.x = -Math.PI / 2; g.position.y = -0.1; g.receiveShadow = true;
            scene.add(g); ground = g;
        }
        ground.scale.set(mapSize * 2, mapSize * 2, 1); 
        updateSun();

        function divide(x, z, w, d) {
            let forceSplit = (w > 400 || d > 400);
            let canSplit = (w > 160 || d > 160);
            
            if (!canSplit || (!forceSplit && Math.random() < 0.15)) {
                if (Math.random() > greenChance) {
                    const dist = Math.sqrt(x*x + z*z);
                    const maxDist = mapSize * 0.55;
                    let u = Math.max(0, 1.0 - (dist / maxDist)); 
                    u = Math.pow(u, 1.5); // Revised Curve
                    
                    const baseH = parseInt(els.height.value);
                    let h = 30 + (baseH * u); // Raised floor
                    if (Math.random() < 0.3) { // Boost chance
                        h += baseH * u * (0.5 + Math.random() * hVar);
                    }
                    h += (Math.random() - 0.5) * 20;
                    h = Math.max(30, h);
                    
                    const rot = Math.floor(Math.random() * 4) * (Math.PI / 2);
                    let genW = w - 2; let genD = d - 2;
                    if (Math.abs(rot - Math.PI/2) < 0.1 || Math.abs(rot - Math.PI*1.5) < 0.1) {
                        const temp = genW; genW = genD; genD = temp;
                    }

                    let style = 'STANDARD'; const rnd = Math.random();
                    if (rnd < styleVar * 0.3) style = 'GLASS'; else if (rnd < styleVar * 0.6) style = 'STEPPED'; else if (rnd < styleVar * 0.8) style = 'TWIN';

                    let shape = 'BOX';
                    if ((style === 'STANDARD' || style === 'GLASS') && Math.random() < shapeComp && w > 40 && d > 40) {
                        const types = ['L', 'U', 'T', 'H']; shape = types[Math.floor(Math.random() * types.length)];
                    }
                    buildingsData.push({ x: x, z: z, w: genW, d: genD, h: h, rot: rot, style: style, shape: shape });
                }
                return;
            }
            const splitX = w > d; const isRoad = (splitX ? w : d) > 250; const gap = isRoad ? minorW : 0; 
            if (splitX) {
                const w1 = (w - gap) / 2; const w2 = w1; divide(x - w/2 + w1/2, z, w1, d); divide(x + w/2 - w2/2, z, w2, d);
            } else {
                const d1 = (d - gap) / 2; const d2 = d1; divide(x, z - d/2 + d1/2, w, d1); divide(x, z + d/2 - d2/2, w, d2);
            }
        }

        const count = Math.ceil((mapSize/2) / majorSpace);
        const lines = []; for(let i = -count; i <= count; i++) lines.push(i * majorSpace);
        
        for(let i = 0; i < lines.length - 1; i++) {
            for(let j = 0; j < lines.length - 1; j++) {
                const xStart = lines[i] + majorWidth/2; const xEnd = lines[i+1] - majorWidth/2;
                const zStart = lines[j] + majorWidth/2; const zEnd = lines[j+1] - majorWidth/2;
                const w = xEnd - xStart; const d = zEnd - zStart; const cx = xStart + w/2; const cz = zStart + d/2;
                if (Math.abs(cx) < mapSize/2 && Math.abs(cz) < mapSize/2) { divide(cx, cz, w, d); }
            }
        }
        buildGeometry(true);
    }

    const heightShader = {
        uniforms: { maxHeight: { value: 300.0 } },
        vertexShader: `varying float vY; void main() { vec4 p = modelMatrix * vec4(position, 1.0); vY = p.y; gl_Position = projectionMatrix * viewMatrix * p; }`,
        fragmentShader: `uniform float maxHeight; varying float vY; void main() { float h = clamp(vY / maxHeight, 0.0, 1.0); gl_FragColor = vec4(vec3(h), 1.0); }`
    };
    
    const blackMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const occluderMat = new THREE.ShaderMaterial({
        vertexShader: 'void main() { gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }',
        fragmentShader: 'void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); }',
        transparent: false, depthTest: true, depthWrite: true
    });
    
    function saveImage(mode) {
        let btn;
        if(mode === 'view') btn = els.exportPng;
        else if(mode === 'depth') btn = els.exportDepth;
        else if(mode === 'shadow') btn = els.exportShadow;
        else btn = els.exportDetail;

        if(btn) btn.disabled = true;
        els.loading.style.display = 'block';
        els.status.innerText = "Encoding...";
        const safeTimer = setTimeout(() => { els.status.innerText = "Reset"; if(btn) btn.disabled=false; els.loading.style.display='none'; }, 15000);

        requestAnimationFrame(() => {
            try {
                const originalSize = new THREE.Vector2();
                renderer.getSize(originalSize);
                const res = parseInt(els.exportRes.value);
                renderer.setSize(res, res);
                if(mode !== 'view') { camera.aspect = 1.0; camera.updateProjectionMatrix(); }

                const originalBg = scene.background;
                const ground = scene.getObjectByName('ground');
                const restoreList = [];

                const oldShadowMap = renderer.shadowMap.enabled;
                if(mode === 'detail') renderer.shadowMap.enabled = false;

                if(mode === 'depth') {
                    scene.background = new THREE.Color(0x000000);
                    scene.overrideMaterial = new THREE.ShaderMaterial({
                        uniforms: { maxHeight: { value: parseInt(els.height.value) * 1.5 } },
                        vertexShader: heightShader.vertexShader, fragmentShader: heightShader.fragmentShader
                    });
                } else if (mode === 'detail') {
                    scene.background = null; renderer.setClearColor(0x000000, 0); 
                    if(ground) ground.visible = false;
                    cityGroup.traverse(obj => {
                        if(obj.userData.isCore || obj.userData.isDetail) { restoreList.push({obj: obj, mat: obj.material}); }
                        if(obj.userData.isCore) obj.material = occluderMat; 
                        if(obj.userData.isDetail) obj.material = blackMat; 
                    });
                } else if (mode === 'shadow') {
                    scene.background = new THREE.Color(0xffffff);
                    scene.overrideMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
                }

                renderer.render(scene, camera);
                renderer.domElement.toBlob(blob => {
                    clearTimeout(safeTimer);
                    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `city_${mode}.png`; a.click();
                    scene.background = originalBg; scene.overrideMaterial = null; renderer.setClearColor(0x000000, 0); scene.background = new THREE.Color(0x111111);
                    if(ground) ground.visible = true;
                    if(mode === 'detail') renderer.shadowMap.enabled = oldShadowMap;
                    restoreList.forEach(item => { item.obj.material = item.mat; });
                    renderer.setSize(originalSize.x, originalSize.y);
                    camera.aspect = originalSize.x / originalSize.y; camera.updateProjectionMatrix();
                    els.status.innerText = "Ready";
                    if(btn) btn.disabled = false; els.loading.style.display = 'none';
                    renderer.render(scene, camera);
                }, 'image/png');
            } catch(e) { clearTimeout(safeTimer); console.error(e); }
        });
    }

    function debounce(func, wait) {
        let timeout;
        return function(...args) { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), wait); };
    }
    const updateLayout = debounce(calculateLayout, 300);
    const updateDetails = debounce(() => buildGeometry(false), 200);

    function updateDarkness() {
        const val = 1.0 - (parseInt(els.darkness.value) / 100.0);
        const col = new THREE.Color(val, val, val);
        detailGroup.traverse(o => {
            if(o.isMesh && o.userData.isDetail) o.material.color.set(col);
        });
    }

    document.querySelectorAll('input[type=range]').forEach(el => {
        el.addEventListener('input', e => {
            const label = document.getElementById(el.id + 'Val');
            if(label) label.innerText = e.target.value;
            
            const type = el.dataset.type;
            if(type === 'camera') { camera.fov = parseInt(el.value); camera.updateProjectionMatrix(); }
            else if(type === 'sun') updateSun();
            else if(type === 'material') updateDarkness();
            else if(type === 'detail') updateDetails();
            else updateLayout();
        });
    });

    els.generate.addEventListener('click', calculateLayout);
    els.exportPng.onclick = () => saveImage('view');
    els.exportDepth.onclick = () => saveImage('depth');
    els.exportShadow.onclick = () => saveImage('shadow');
    els.exportDetail.onclick = () => saveImage('detail');

    // RESTORED VIEW BUTTONS
    document.getElementById('viewTop').onclick = () => {
        controls.target.set(0, 0, 0);
        camera.position.set(0, parseInt(els.area.value) * 0.8, 0);
        camera.fov = parseInt(els.fov.value); camera.updateProjectionMatrix(); controls.update();
    };
    document.getElementById('viewSide').onclick = () => {
        controls.target.set(0, 0, 0);
        const dist = parseInt(els.area.value) * 0.6;
        camera.position.set(dist, dist * 0.6, dist);
        camera.fov = parseInt(els.fov.value); camera.updateProjectionMatrix(); controls.update();
    };
    document.getElementById('viewPlanet').onclick = () => {
        controls.target.set(0, 0, 0);
        camera.position.set(0, 800, 0.1); 
        camera.fov = 150; camera.updateProjectionMatrix(); controls.update();
    };

    function updateSaveList() {
        els.saveList.innerHTML = "";
        for(let i=0; i<localStorage.length; i++) {
            const key = localStorage.key(i);
            if(key.startsWith("citygen_")) {
                const opt = document.createElement("option");
                opt.value = key; opt.innerText = key.replace("citygen_", ""); els.saveList.appendChild(opt);
            }
        }
    }
    els.saveBtn.onclick = () => {
        const name = els.saveName.value.trim(); if(!name) return;
        const data = { cam: camera.position.toArray(), tgt: controls.target.toArray() };
        Object.keys(els).forEach(k => { if(els[k].tagName === 'INPUT' && els[k].type === 'range') data[k] = els[k].value; });
        localStorage.setItem("citygen_" + name, JSON.stringify(data));
        updateSaveList();
    };
    els.loadBtn.onclick = () => {
        const key = els.saveList.value; if(!key) return;
        const d = JSON.parse(localStorage.getItem(key));
        Object.keys(d).forEach(k => { 
            if(els[k]) { els[k].value = d[k]; const l = document.getElementById(k+'Val'); if(l) l.innerText = d[k]; }
        });
        if(d.cam) camera.position.fromArray(d.cam);
        if(d.tgt) controls.target.fromArray(d.tgt);
        calculateLayout();
    };
    els.deleteBtn.onclick = () => {
        const key = els.saveList.value;
        if(key && confirm("Delete?")) { localStorage.removeItem(key); updateSaveList(); }
    };

    updateSaveList();
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    calculateLayout();
    
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
        const s = new THREE.Spherical().setFromVector3(camera.position);
        if(document.activeElement !== els.polarInput) els.polarInput.value = Math.round(THREE.MathUtils.radToDeg(s.phi));
        if(document.activeElement !== els.azInput) els.azInput.value = Math.round(THREE.MathUtils.radToDeg(s.theta));
    }
    animate();

</script>
</body>
</html>
